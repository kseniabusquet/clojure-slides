{:title "Workshop de Clojure"
 :templates [
   {; Template 1: O Padrão
    :id "content"
    :style "background: linear-gradient(to bottom, #587CC0 15%, #FFFFFF 15%)"
    :elements [{:type "text"
                :style "left: 5%; top: 3%; color: #F9F9F9; text-align: left"}
               {:type "text"
                :style "left: 5%; top: 20%; color: #222222; text-align: left"}]}

   {; Template 2: Título Principal
    :id "title"
    :style "background: linear-gradient(to bottom, #587CC0 50%, #7EBA46 50%)"
    :elements [{:type "text"
                :style "left: 10%; top: 20%; color: #FFFFFF; text-align: center; width: 80%"}
               {:type "text"
                :style "left: 10%; top: 60%; color: #FFFFFF; text-align: center; width: 80%"}]}

   {; Template 3: Código (Escuro)
    :id "code"
    :style "background: #222222"
    :elements [{:type "text"
                :style "left: 5%; top: 5%; color: #7EBA46; text-align: left"}
               {:type "text"
                :style "left: 5%; top: 15%; color: #F9F9F9; text-align: left"}]}

   {; Template 4: Duas Colunas
    :id "split"
    :style "background: linear-gradient(to bottom, #587CC0 15%, #FFFFFF 15%)"
    :elements [{:type "text" ; Título
                :style "left: 5%; top: 3%; color: #F9F9F9"}
               {:type "text" ; Coluna Esq
                :style "left: 5%; top: 20%; color: #222222; width: 45%"}
               {:type "text" ; Coluna Dir
                :style "left: 52%; top: 20%; color: #222222; width: 45%"}]}

   {; Template 5: Imagem Centralizada
    :id "image-center"
    :style "background: linear-gradient(to bottom, #587CC0 50%, #7EBA46 50%)"
    :elements [{:type "text"
                :style "left: 10%; top: 20%; color: #FFFFFF; text-align: center; width: 80%"}
                {:type "image"
                :style "left: 0; top: 10%; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center"}]},


    {; Template 6: Estatísticas
     :id "survey-stats"
     :style "background: linear-gradient(to bottom, #587CC0 15%, #FFFFFF 15%)"
     :elements [{:type "text"
                 :style "left: 5%; top: 3%; color: #F9F9F9; text-align: left"}
                {:type "html"
                 :style "left: 5%; top: 20%; color: #222222; width: 90%; height: 100%; overflow-y: auto"}]}]}
END
-*-*- [title] Workshop de Clojure
# Clojure: A Vida é uma Lista '(e o código é lindo).

### Um Lisp moderno para a JVM (e além!)

-*-*- O que vamos ver hoje?
# Agenda

1.  **Filosofia:** Por que Clojure é diferente?
2.  **Fundamentos:** Sintaxe e REPL.
3.  **Dados:** Imutabilidade e Estruturas.
4.  **Funcional:** Map, Filter, Reduce.
5.  **Composição:** Threading Macros.
6.  **Prática:** Estado e Java Interop.

-*-*- O que é Clojure?
# O que é Clojure?

* Uma **Linguagem Dinâmica** (como Python ou Ruby).
* Uma **Linguagem Funcional** (ênfase em funções e imutabilidade).
* Um **Dialeto Lisp** (código é dado, sintaxe simples).
* "Hospedada" (roda na **JVM**, **Javascript**, .NET, etc.).
* Focada em **Simplicidade** e **Concorrência**.

-*-*- [split] Simples vs. Fácil
# Filosofia: Simples vs. Fácil

**"Fácil" (Easy)**
* Significa "próximo", "familiar".
* Ex: Um IDE com 1000 botões. É fácil de *começar* a clicar.
* O fácil muitas vezes esconde complexidade ("mágica") que cobra o preço depois.



**"Simples" (Simple)**
* O oposto de "complexo" (que significa entrelaçado).
* Uma ferramenta simples faz **uma** coisa.
* Peças simples podem ser compostas para construir sistemas robustos.
* *Rich Hickey*: "Simplicidade é um pré-requisito para confiabilidade."

-*-*- Pilar 1: Code is Data
# Filosofia: Code is Data (Homoiconicidade)

Em Lisp, o código é escrito usando as próprias estruturas de dados da linguagem.

* O código é apenas uma **Lista**.
* O primeiro elemento é a função, o resto são os argumentos.
* O computador sabe "ler" essa lista e executar.
* Isso permite **Macros**: escrever código que escreve código de forma trivial.

-*-*- [code] Exemplo de Sintaxe
# Tudo é uma Lista



```clojure
;; Em Java/C#:  method(arg1, arg2)
;; Em Clojure: (funcao arg1 arg2)

;; Soma simples
(+ 1 2 3) ; => 6

;; Uma lista de dados (com ' para não executar)
'(1 2 3)

;; Se eu tirar o quote ', o Clojure tenta executar o "1"
(1 2 3) ; Erro! 1 não é uma função.
```

-*-*- O Coração: REPL
# O REPL (Read-Eval-Print-Loop)

Esqueça o ciclo "Escrever -> Compilar -> Esperar -> Rodar".

* No Clojure, você programa com a aplicação **rodando**.
* Você envia pedaços de código para o REPL e vê o resultado instantaneamente.
* É uma conversa com o seu programa, não um monólogo.
* Feedback loop extremamente rápido = Maior produtividade.

-*-*- [split] Imutabilidade
# Pilar 2: Imutabilidade

**O Problema da Mutabilidade**
* Se algo pode mudar a qualquer momento, você precisa "travar" (Lock) o código para evitar que duas threads mexam ao mesmo tempo.
* Isso gera *Race Conditions*, Deadlocks e bugs difíceis de rastrear.



**A Solução Clojure**
* Valores não mudam. Nunca.
* Quer mudar um vetor? Você cria um **novo** vetor com a alteração.
* O antigo continua lá, intacto.
* Isso torna a concorrência trivial e segura. Não precisa de Locks!

-*-*- [code] Estruturas de Dados
# Estruturas de Dados Literais



```clojure
;; Vetor (acesso rápido por índice)
[1 "olá" :keyword 3.14]

;; Mapa (chave-valor)
{:nome "Ana" :idade 30 :skills [:clojure :java]}

;; Lista (S-expression, sequencial)
'(+ 1 2)

;; Set (valores únicos)
#{:a :b :c :a} ; => #{:a :b :c}
```

-*-*- [split] Pensamento Funcional
# Pensamento Funcional

**Dados fluem, não mudam**
Em vez de loops `for` alterando variáveis, usamos funções de ordem superior.

* **Map:** Transforma cada item.
* **Filter:** Seleciona itens.
* **Reduce:** Combina itens em um resultado.



**Exemplos Conceituais**

```clojure
(map inc [1 2]) ; -> '(2 3)
(filter even? [1 2 3] ); -> '(2)
(reduce + [1 2 3]) ; -> 6
```

-*-*- [code] Core Functions
# O poder do Core



```clojure
(def numeros [1 2 3 4 5])

;; Multiplicar todos por 10
(map #(* % 10) numeros)
;; => (10 20 30 40 50)

;; Pegar só os maiores que 3
(filter #(> % 3) numeros)
;; => (4 5)

;; Somar tudo
(reduce + numeros)
;; => 15
```

-*-*- [code] O Problema do Aninhamento
# O Problema da Leitura (Nesting)

Sem composição, o código cresce para "dentro" (inside-out).



```clojure
;; Objetivo:
;; Pegar usuários, filtrar ativos,
;; pegar o email e converter para caixa alta.

(map upper-case
  (map :email
    (filter :active?
      (get-users))))

;; Difícil de ler a ordem de execução!
;; Temos que ler de baixo para cima, de dentro pra fora.
```

-*-*- [code] Threading Macros
# A Solução: Threading Macros (->>)

O operador `->>` passa o resultado da linha anterior como o *último* argumento da próxima linha.



```clojure
(->> (get-users)          ; Pega usuários
     (filter :active?)    ; Filtra ativos
     (map :email)         ; Extrai emails
     (map str/upper-case) ; Converte para MAIÚSCULAS
     (sort))              ; Ordena

;; Muito mais legível!
;; Lê-se de cima para baixo, como uma receita.
```

-*-*- [split] Gerenciamento de Estado
# E quando precisamos de Estado?

**O Mundo é Mutável**
Apesar da imutabilidade interna, precisamos lidar com banco de dados, tela do usuário, etc.

Clojure isola a mutabilidade em tipos específicos chamados de **Referências**.



**Atoms**
* O tipo mais comum para estado local.
* É como uma "caixa" que guarda um valor imutável.
* Você pode trocar o valor da caixa de forma atômica (thread-safe).

-*-*- [code] Usando Atoms
# Brincando com o Tempo (Estado)



```clojure
;; Criando um atom (estado inicial 0)
(def contador (atom 0))

@contador ; => 0 (Lendo o valor)

;; Alterando o valor (swap! aplica uma função)
(swap! contador inc) ; => 1
(swap! contador + 10) ; => 11

;; Resetando forçadamente
(reset! contador 0) ; => 0
```

-*-*- [split] Java Interop
# Java Interop

**O Poder da JVM**
Clojure não vive numa ilha. Ele abraça a JVM.

Você pode usar **qualquer** biblioteca Java (Spring, Hibernate, Apache Commons, Drivers JDBC) nativamente, sem wrappers.



**Sintaxe Simples**
* `.` para chamar métodos.
* `/` para métodos estáticos.
* `new` (ou `.`) para instanciar.

-*-*- [code] Java Interop Exemplos
# Usando Java no Clojure



```clojure
;; Instanciando uma data
(java.util.Date.)
;; => #inst "2023-10-27..."

;; Chamando método estático
(Math/pow 2 10)
;; => 1024.0

;; Chamando método de instância (.toUpperCase)
(.toUpperCase "clojure é legal")
;; => "CLOJURE É LEGAL"

```

-*-*- Concorrência
# Concorrência sem Dor

Além de Atoms, Clojure oferece ferramentas de alto nível:

* **Futures:** Execute algo em outra thread e pegue o valor depois.
  `(future (processamento-pesado))`
* **Promises:** Promessa de um valor futuro.
* **pmap:** "Parallel Map". Processa uma lista usando múltiplos núcleos da CPU automaticamente.
  `(pmap processar-dados lista-gigante)`

-*-*- Próximos Passos
# Próximos Passos

1.  **Instale:** Leiningen ou Clojure CLI.
2.  **Editor:** VS Code (Calva) ou IntelliJ (Cursive).
3.  **Pratique:** 4clojure.oxal.org (Exercícios lógicos).
4.  **Livro:** "Clojure for the Brave and True" (Grátis online).

-*-*- [title] Obrigado!
# Obrigado!

Perguntas?

*(Gerado via SlideMD)*

-*-*- [image-center] Questionário

# Questionário para a parte interativa

![QR Code](./assets/img/survey-qr-code.png)
